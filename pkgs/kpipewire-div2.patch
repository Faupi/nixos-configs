From d3f569a12452ae9a52b4169a76925387fb570d0f Mon Sep 17 00:00:00 2001
From: Arjen Hiemstra <ahiemstra@heimr.nl>
Date: Mon, 14 Oct 2024 10:58:53 +0200
Subject: [PATCH 1/2] encoder: Make it possble to override the filter graph
 used for software encode

We may want to adjust the filter graph in an encoder to insert
additional filters. Rather than overriding the full method for creating
the filter graph, which would lead to a lot of duplication, this simply
exposes the string that is passed to FFmpeg for parsing.
---
 src/encoder.cpp | 2 +-
 src/encoder_p.h | 9 +++++++++
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/src/encoder.cpp b/src/encoder.cpp
index e662c61..43adb3c 100644
--- a/src/encoder.cpp
+++ b/src/encoder.cpp
@@ -314,7 +314,7 @@ bool SoftwareEncoder::createFilterGraph(const QSize &size)
     outputs->pad_idx = 0;
     outputs->next = nullptr;
 
-    ret = avfilter_graph_parse(m_avFilterGraph, "format=pix_fmts=yuv420p", outputs, inputs, NULL);
+    ret = avfilter_graph_parse(m_avFilterGraph, m_filterGraphToParse.toUtf8().data(), outputs, inputs, NULL);
     if (ret < 0) {
         qCWarning(PIPEWIRERECORD_LOGGING) << "Failed creating filter graph";
         return false;
diff --git a/src/encoder_p.h b/src/encoder_p.h
index 6360535..9e1d3f0 100644
--- a/src/encoder_p.h
+++ b/src/encoder_p.h
@@ -135,6 +135,15 @@ protected:
      */
     bool createFilterGraph(const QSize &size);
 
+    /**
+     * The filter graph to be passed to FFmpeg to parse.
+     *
+     * Adjust this if you need to insert any extra filters in between input and
+     * output filters.
+     *
+     * You should make sure that the output format of the filter graph is yuv420p.
+     */
+    QString m_filterGraphToParse = QStringLiteral("format=pix_fmts=yuv420p");
     DmaBufHandler m_dmaBufHandler;
 };
 
-- 
GitLab


From 3000de742535f4119513429c442d4e4ce361c8d5 Mon Sep 17 00:00:00 2001
From: Arjen Hiemstra <ahiemstra@heimr.nl>
Date: Mon, 14 Oct 2024 11:03:55 +0200
Subject: [PATCH 2/2] libx264encoder: Ensure stream size is always a multiple
 of 2

libx264 apparently rejects any stream that is not a multiple of 2. So
ensure we adjust the stream size to that. This also inserts a pad filter
to ensure we pad with black rather than garbage.

BUG: 485733
---
 src/libx264encoder.cpp | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/src/libx264encoder.cpp b/src/libx264encoder.cpp
index 04eb5ec..9101164 100644
--- a/src/libx264encoder.cpp
+++ b/src/libx264encoder.cpp
@@ -20,10 +20,16 @@ extern "C" {
 
 #include "logging_record.h"
 
+using namespace Qt::StringLiterals;
+
 LibX264Encoder::LibX264Encoder(H264Profile profile, PipeWireProduce *produce)
     : SoftwareEncoder(produce)
     , m_profile(profile)
 {
+    // Adjust the filter graph to ensure we are using an even frame size using a
+    // pad filter. Otherwise the size adjustment below will insert a row/column
+    // of garbage instead of black.
+    m_filterGraphToParse = u"pad=ceil(iw/2)*2:ceil(ih/2)*2,format=pix_fmts=yuv420p"_s;
 }
 
 bool LibX264Encoder::initialize(const QSize &size)
@@ -43,8 +49,12 @@ bool LibX264Encoder::initialize(const QSize &size)
     }
 
     Q_ASSERT(!size.isEmpty());
-    m_avCodecContext->width = size.width();
-    m_avCodecContext->height = size.height();
+    // Important: libx264 rejects streams with sizes that are not even. So to
+    // ensure we don't get errors, we need to ensure the size we set here is
+    // even. We also insert a pad filter into the filter chain above to ensure
+    // we don't end up padding with garbage.
+    m_avCodecContext->width = std::ceil(size.width() / 2) * 2;
+    m_avCodecContext->height = std::ceil(size.height() / 2) * 2;
     m_avCodecContext->max_b_frames = 0;
     m_avCodecContext->gop_size = 100;
     m_avCodecContext->pix_fmt = AV_PIX_FMT_YUV420P;
-- 
GitLab

